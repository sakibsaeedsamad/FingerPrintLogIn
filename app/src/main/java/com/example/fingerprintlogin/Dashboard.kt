package com.example.fingerprintlogin

import android.os.Build
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import android.util.Base64
import android.util.Log
import android.widget.Toast
import androidx.annotation.Nullable
import androidx.annotation.RequiresApi
import androidx.biometric.BiometricManager
import androidx.biometric.BiometricPrompt
import kotlinx.android.synthetic.main.activity_dashboard.*
import java.security.*
import java.security.spec.ECGenParameterSpec
import java.util.*
import java.util.concurrent.Executor

class Dashboard : AppCompatActivity() {
    private var mToBeSignedMessage: String? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_dashboard)


        btn_register_fingerprint.setOnClickListener {
            if (canAuthenticateWithStrongBiometrics()) {  // Check whether this device can authenticate with biometrics
                Log.i(Dashboard.Companion.TAG, "Try registration")
                // Generate keypair and init signature
                val signature: Signature?
                try {
                    val keyPair: KeyPair = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                        generateKeyPair(Dashboard.Companion.KEY_NAME, true)
                    } else {
                        TODO("VERSION.SDK_INT < M")
                    }
                    // Send public key part of key pair to the server, this public key will be used for authentication
                    mToBeSignedMessage =
                        Base64.encodeToString(keyPair.public.encoded, Base64.URL_SAFE)
                            .toString() +
                                ":" +
                                Dashboard.Companion.KEY_NAME +
                                ":" +  // Generated by the server to protect against replay attack
                                "784159623"
                    signature = initSignature(Dashboard.Companion.KEY_NAME)
                } catch (e: Exception) {
                    throw RuntimeException(e)
                }

                // Create biometricPrompt
                showBiometricPrompt(signature)
            } else {
                // Cannot use biometric prompt
                Toast.makeText(this, "Cannot use biometric", Toast.LENGTH_SHORT).show()
            }
        }
    }

    @RequiresApi(Build.VERSION_CODES.M)
    @Throws(Exception::class)
    private fun generateKeyPair(
        keyName: String,
        invalidatedByBiometricEnrollment: Boolean
    ): KeyPair {
        val keyPairGenerator: KeyPairGenerator =
            KeyPairGenerator.getInstance(KeyProperties.KEY_ALGORITHM_EC, "AndroidKeyStore")
        val builder = KeyGenParameterSpec.Builder(
            keyName,
            KeyProperties.PURPOSE_SIGN
        )
            .setAlgorithmParameterSpec(ECGenParameterSpec("secp256r1"))
            .setDigests(
                KeyProperties.DIGEST_SHA256,
                KeyProperties.DIGEST_SHA384,
                KeyProperties.DIGEST_SHA512
            ) // Require the user to authenticate with a biometric to authorize every use of the key
            .setUserAuthenticationRequired(true)

        // Generated keys will be invalidated if the biometric templates are added more to user device
        if (Build.VERSION.SDK_INT >= 24) {
            builder.setInvalidatedByBiometricEnrollment(invalidatedByBiometricEnrollment)
        }
        keyPairGenerator.initialize(builder.build())
        return keyPairGenerator.generateKeyPair()
    }

    @Nullable
    @Throws(Exception::class)
    private fun getKeyPair(keyName: String): KeyPair? {
        val keyStore: KeyStore = KeyStore.getInstance("AndroidKeyStore")
        keyStore.load(null)
        if (keyStore.containsAlias(keyName)) {
            // Get public key
            val publicKey: PublicKey = keyStore.getCertificate(keyName).publicKey
            // Get private key
            val privateKey: PrivateKey = keyStore.getKey(keyName, null) as PrivateKey
            // Return a key pair
            return KeyPair(publicKey, privateKey)
        }
        return null
    }

    @Nullable
    @Throws(Exception::class)
    private fun initSignature(keyName: String): Signature? {
        val keyPair: KeyPair? = getKeyPair(keyName)
        if (keyPair != null) {
            val signature: Signature = Signature.getInstance("SHA256withECDSA")
            signature.initSign(keyPair.private)
            return signature
        }
        return null
    }

    private val mainThreadExecutor: Executor
        get() = MainThreadExecutor()

    private class MainThreadExecutor() : Executor {
        private val handler: Handler = Handler(Looper.getMainLooper())
        override fun execute(r: Runnable) {
            handler.post(r)
        }
    }

    private fun showBiometricPrompt(signature: Signature?) {
        val authenticationCallback: BiometricPrompt.AuthenticationCallback =
            authenticationCallback
        val mBiometricPrompt = BiometricPrompt(
            this,
            mainThreadExecutor, authenticationCallback
        )

        // Set prompt info
        val promptInfo: BiometricPrompt.PromptInfo = BiometricPrompt.PromptInfo.Builder()
            .setDescription("Description")
            .setTitle("Title")
            .setSubtitle("Subtitle")
            .setNegativeButtonText("Cancel")
            .build()

        // Show biometric prompt
        if (signature != null) {
            Log.i(Dashboard.Companion.TAG, "Show biometric prompt")
            mBiometricPrompt.authenticate(promptInfo, BiometricPrompt.CryptoObject(signature))
        }
    }// Error// Normally, ToBeSignedMessage and Signature are sent to the server and then verified

    // Callback for biometric authentication result
    private val authenticationCallback: BiometricPrompt.AuthenticationCallback
        get() =// Callback for biometric authentication result
            object : BiometricPrompt.AuthenticationCallback() {
                override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {
                    Log.e(
                        Dashboard.Companion.TAG,
                        "Error code: " + errorCode + "error String: " + errString
                    )
                    super.onAuthenticationError(errorCode, errString)
                }

                override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {
                    Log.i(Dashboard.Companion.TAG, "onAuthenticationSucceeded")
                    super.onAuthenticationSucceeded(result)
                    if (result.cryptoObject != null &&
                        result.cryptoObject!!.signature != null
                    ) {
                        try {
                            var signature: Signature? = result.cryptoObject!!.signature
                            signature?.update(mToBeSignedMessage!!.toByteArray())
                            val signatureString: String =
                                Base64.encodeToString(signature?.sign(), Base64.URL_SAFE)
                            // Normally, ToBeSignedMessage and Signature are sent to the server and then verified
                            Log.i(Dashboard.Companion.TAG, "Message: $mToBeSignedMessage")
                            Log.i(
                                Dashboard.Companion.TAG,
                                "Signature (Base64 Encoded): $signatureString"
                            )
                            Toast.makeText(
                                applicationContext,
                                "$mToBeSignedMessage:$signatureString", Toast.LENGTH_SHORT
                            ).show()
                        } catch (e: SignatureException) {
                            throw RuntimeException()
                        }
                    } else {
                        // Error
                        Toast.makeText(applicationContext, "Something wrong", Toast.LENGTH_SHORT)
                            .show()
                    }
                }

                override fun onAuthenticationFailed() {
                    super.onAuthenticationFailed()
                }
            }

    private fun canAuthenticateWithStrongBiometrics(): Boolean {
        return BiometricManager.from(this)
            .canAuthenticate(BiometricManager.Authenticators.BIOMETRIC_STRONG) === BiometricManager.BIOMETRIC_SUCCESS
    }

    companion object {
        private val TAG = MainActivity::class.java.name

        // Unique identifier of a key pair
        private val KEY_NAME: String = UUID.randomUUID().toString()
    }
}